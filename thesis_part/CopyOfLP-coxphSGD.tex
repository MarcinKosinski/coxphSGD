\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.00,1.00}{{#1}}}
\newcommand{\DataTypeTok}[1]{{#1}}
\newcommand{\DecValTok}[1]{{#1}}
\newcommand{\BaseNTok}[1]{{#1}}
\newcommand{\FloatTok}[1]{{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.00,0.50,0.50}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{1.00,0.25,0.00}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{{#1}}}
\newcommand{\FunctionTok}[1]{{#1}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textbf{{#1}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={autor},
            pdftitle={tytul},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}
  \title{tytul}
  \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
  \author{autor}
  \preauthor{\centering\large\emph}
  \postauthor{\par}
  \predate{\centering\large\emph}
  \postdate{\par}
  \date{data}

%
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{amssymb,amsmath}


\begin{document}

\maketitle


Algorytm jest dostępny w specjalnie przygotowanym pakiecie o nazwie
\texttt{coxphSGD} napisanym w języku \(\mathcal{R}\), który można pobrać
z internetu i zainstalować poleceniem

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{if (}\KeywordTok{packageVersion}\NormalTok{(}\StringTok{"devtools"}\NormalTok{) <}\StringTok{ }\FloatTok{1.6}\NormalTok{) \{}
  \KeywordTok{install.packages}\NormalTok{(}\StringTok{"devtools"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{devtools::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"MarcinKosinski/Cox-SGD"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Poniżej przedstawione są argumenty, które przyjmuje funkcja
\texttt{coxphSGD()}, która estymuje współczynniki w modelu
proporcjonalnych hazardów Coxa metodą stochastycznego spadku gradientu.
Starano zachować jednorodność kolejności i nazewnictwa parametrów z
funkcją \texttt{coxph} z pakietu \texttt{survival} \cite{ther},
\cite{survival}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#' Stochastic Gradient Descent log-likelihood estimation in }
\CommentTok{#' Cox proportional hazards model}
\CommentTok{#' }
\CommentTok{#' Function \textbackslash{}code\{coxphSGD\} estimates coefficients using stochastic}
\CommentTok{#' gradient descent algorithm in Cox proportional hazards model.}
\CommentTok{#' }
\CommentTok{#' @param formula a formula object, with the response on the left of a ~ operator,}
\CommentTok{#' and the terms on the right. The response must be a survival object as returned by}
\CommentTok{#' the Surv function.}
\CommentTok{#' @param data a data.frame in which to interpret the variables named in the \textbackslash{}code\{formula\}.}
\CommentTok{#' @param reorderObs a logical value telling whether reorder observations at each epoch.}
\CommentTok{#' when order of observations in estimation should be randomly generated.}
\CommentTok{#' @param learningRates a function specifing how to define learning rates in }
\CommentTok{#' steps of the algorithm. By default the \textbackslash{}code\{f(t)=1/t\} is used, where \textbackslash{}code\{t\} is}
\CommentTok{#' the number of algorithm's step.}
\CommentTok{#' @param beta_0 a numeric vector (if of length 1 then will be replicated) of length }
\CommentTok{#' equal to the number of variables after using \textbackslash{}code\{formula\} in the \textbackslash{}code\{model.matrix\}}
\CommentTok{#' function}
\CommentTok{#' @param epsilon a numeric value with the stop condition of the estimation algorithm. }
\CommentTok{#' @param epoch a numeric value declaring the number of epoches to run for the}
\CommentTok{#' estimation algorithm in the stochastic gradient descent.}
\CommentTok{#' @param batchSize a numeric value specifing the size of a batch set to take from }
\CommentTok{#' the reordered dataset to update the coefficients in one step of an algorithm.}
\CommentTok{#'}
\CommentTok{#' @note If one of the conditions is fullfiled}
\CommentTok{#' \textbackslash{}itemize\{}
\CommentTok{#'  \textbackslash{}item \textbackslash{}eqn\{||\textbackslash{}beta_\{j+1\}-\textbackslash{}beta_\{j\}|| <\}\textbackslash{}code\{epsilon\} parameter for any \textbackslash{}eqn\{j\}}
\CommentTok{#'  \textbackslash{}item \textbackslash{}eqn\{#epochs >\} \textbackslash{}code\{epochs\} parameter}
\CommentTok{#' \}}
\CommentTok{#' the estimation process is stopped.}
\CommentTok{#' @export}
\CommentTok{#' @importFrom survival Surv}
\CommentTok{#' @importFrom assertthat assert_that}
\CommentTok{#' @examples}
\CommentTok{#' library(survival)}
\CommentTok{#' \textbackslash{}dontrun\{}
\CommentTok{#' coxphSGD(Surv(time, status) ~ ph.ecog + age, data=lung)}
\CommentTok{#' \}}
\CommentTok{#' }
\end{Highlighting}
\end{Shaded}

Sprawdzenie parametrów na wejściu funkcji.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coxphSGD =}\StringTok{ }\NormalTok{function(formula, data, }\DataTypeTok{reorderObs =} \OtherTok{TRUE}\NormalTok{,}
                    \DataTypeTok{learningRates =} \NormalTok{function(x) }\DecValTok{1}\NormalTok{/x,}
                    \DataTypeTok{beta_0 =} \DecValTok{0}\NormalTok{, }\DataTypeTok{epsilon =} \FloatTok{1e-5}\NormalTok{,}
                    \DataTypeTok{batchSize =} \DecValTok{10}\NormalTok{, }\DataTypeTok{epoch =} \DecValTok{20} \NormalTok{) \{}
  
  \KeywordTok{assert_that}\NormalTok{(}\KeywordTok{is.data.frame}\NormalTok{(data))}
  \KeywordTok{assert_that}\NormalTok{(}\KeywordTok{is.logical}\NormalTok{(reorderObs))}
  \KeywordTok{assert_that}\NormalTok{(}\KeywordTok{is.function}\NormalTok{(learningRates))}
  \KeywordTok{assert_that}\NormalTok{(}\KeywordTok{is.numeric}\NormalTok{(epsilon))}
  \KeywordTok{assert_that}\NormalTok{(}\KeywordTok{is.numeric}\NormalTok{(epoch) &}\StringTok{ }\NormalTok{epoch >}\StringTok{ }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Identyfikacja przekazanych parametrów. Poniższa identyfikacja bazuje na
kodzie funkcji \texttt{coxph()}.

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{Call <-}\StringTok{ }\KeywordTok{match.call}\NormalTok{()}
  \NormalTok{indx <-}\StringTok{ }\KeywordTok{match}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"formula"}\NormalTok{, }\StringTok{"data"}\NormalTok{, }\StringTok{"order"}\NormalTok{, }\StringTok{"learningRates"}\NormalTok{,}
                  \StringTok{"epsilon"}\NormalTok{, }\StringTok{"batchsize"}\NormalTok{, }\StringTok{"epoch"}\NormalTok{),}
                \KeywordTok{names}\NormalTok{(Call), }\DataTypeTok{nomatch =} \DecValTok{0}\NormalTok{)}
  \NormalTok{if (indx[}\DecValTok{1}\NormalTok{] ==}\StringTok{ }\DecValTok{0}\NormalTok{) }
      \KeywordTok{stop}\NormalTok{(}\StringTok{"A formula argument is required"}\NormalTok{)}
  \NormalTok{temp <-}\StringTok{ }\NormalTok{Call[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, indx)]}
  \NormalTok{temp[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\KeywordTok{as.name}\NormalTok{(}\StringTok{"model.frame"}\NormalTok{)}
  
  \NormalTok{mf <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(temp, }\KeywordTok{parent.frame}\NormalTok{())}
  \NormalTok{Y <-}\StringTok{ }\KeywordTok{model.extract}\NormalTok{(mf, }\StringTok{"response"}\NormalTok{)}
  
  \NormalTok{if (!}\KeywordTok{inherits}\NormalTok{(Y, }\StringTok{"Surv"}\NormalTok{)) }
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Response must be a survival object"}\NormalTok{)}
  \NormalTok{type <-}\StringTok{ }\KeywordTok{attr}\NormalTok{(Y, }\StringTok{"type"}\NormalTok{)}
  
  \NormalTok{if (type !=}\StringTok{ "right"} \NormalTok{&&}\StringTok{ }\NormalTok{type !=}\StringTok{ "counting"}\NormalTok{) }
      \KeywordTok{stop}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"Cox model doesn't support }\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, type, }\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{ survival data"}\NormalTok{, }
          \DataTypeTok{sep =} \StringTok{""}\NormalTok{))}
  \NormalTok{if (}\KeywordTok{length}\NormalTok{(beta_0) ==}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
    \NormalTok{beta_0 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(beta_0, }\KeywordTok{ncol}\NormalTok{(mf)-}\DecValTok{1}\NormalTok{)}
  \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Początkowa zamiana kolejności obserwacji w wejściowym zbiorze.

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{if (reorderObs) \{}
    \NormalTok{obsOrder <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\NormalTok{:}\KeywordTok{nrow}\NormalTok{(data))}
    \NormalTok{mf <-}\StringTok{ }\NormalTok{mf[obsOrder, ]}
    \NormalTok{Y <-}\StringTok{ }\NormalTok{Y[obsOrder, ]}
  \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Wprowadzenie zmiennych pomocniczych.

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{j <-}\StringTok{ }\DecValTok{0} \CommentTok{# number of an algorithm's step}
  \NormalTok{diff <-}\StringTok{ }\DecValTok{0} \CommentTok{# differences between estimates along steps}
  \NormalTok{i <-}\StringTok{ }\DecValTok{0} \CommentTok{# indicator of a batch sample}
  \NormalTok{n <-}\StringTok{ }\KeywordTok{nrow}\NormalTok{(data)}
  \NormalTok{batchSamplesStarts <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,n, batchSize) }\CommentTok{# indexes of starts of batch samples}
  \NormalTok{epochs_n <-}\StringTok{ }\DecValTok{1}\CommentTok{# indicator of the present epochs number}
  \NormalTok{beta_j <-}\StringTok{ }\NormalTok{beta_0}
\end{Highlighting}
\end{Shaded}

gdzie
\[ \text{diff}_{j} = \parallel \beta_{j+1}-\beta_j\parallel < \epsilon .\]
Sprawdzenie warunku zbieżności algorytmu.

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{while ( j ==}\StringTok{ }\DecValTok{0} \NormalTok{|}\StringTok{ }\NormalTok{(diff <}\StringTok{ }\NormalTok{eps &}\StringTok{ }\NormalTok{epochs_n <=}\StringTok{ }\NormalTok{epoch) )\{}
    \NormalTok{j <-}\StringTok{ }\NormalTok{j}\DecValTok{+1}
    \NormalTok{i <-}\StringTok{ }\NormalTok{i}\DecValTok{+1}
\end{Highlighting}
\end{Shaded}

Rozpoczęcie algorytmu. Dla losowej kolejności obserwacji, weź pierwszą
porcję obserwacji, której wielkość ustawiona jest dzięki parametrowi
\texttt{batchSize}. Tak powstaje podzbiór obserwacji oznaczany przez
\(\mathcal{B}\), dla którego zachodzi \(|\mathcal{B}| = b\), a \(b\)
odpowiada wartości ustawionej w parametrze \texttt{batchSize}. Indeksy
obserwacji należace do zbioru \(\mathcal{B}\) zdefiniujmy jako
\(\mathcal{B}_{\text{ind}} = \{i: X_i \in \mathcal{B} \}\).

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{if (i <}\StringTok{ }\KeywordTok{length}\NormalTok{(batchSamplesStarts)-}\DecValTok{1}\NormalTok{)\{}
    \NormalTok{batchSample_variables <-}\StringTok{ }\NormalTok{mf[batchSamplesStarts[i]:(batchSamplesStarts[i]+batchSize}\DecValTok{-1}\NormalTok{), ]}
    \NormalTok{batchSample_response <-}\StringTok{ }\NormalTok{Y[batchSamplesStarts[i]:(batchSamplesStarts[i]+batchSize}\DecValTok{-1}\NormalTok{), ]}
  \NormalTok{\} else \{}
    \NormalTok{if (i ==}\StringTok{ }\KeywordTok{length}\NormalTok{(batchSamplesStarts)-}\DecValTok{1}\NormalTok{) \{}
      \CommentTok{# last batch sample can me shorter than all others}
      \NormalTok{batchSample_variables <-}\StringTok{ }\NormalTok{mf[batchSamplesStarts[i]:(n), ]}
      \NormalTok{batchSample_response <-}\StringTok{ }\NormalTok{Y[batchSamplesStarts[i]:(n), ]}
    \NormalTok{\} else \{}
      \NormalTok{i <-}\StringTok{ }\DecValTok{1}
      \NormalTok{batchSample_variables <-}\StringTok{ }\NormalTok{mf[batchSamplesStarts[i]:(batchSamplesStarts[i]+batchSize}\DecValTok{-1}\NormalTok{), ]}
      \NormalTok{batchSample_response <-}\StringTok{ }\NormalTok{Y[batchSamplesStarts[i]:(batchSamplesStarts[i]+batchSize}\DecValTok{-1}\NormalTok{), ]}
      \NormalTok{epochs_n <-}\StringTok{ }\NormalTok{epochs_n +}\StringTok{ }\DecValTok{1} \CommentTok{# epoch has passed}
      \CommentTok{# so reorder samples}
        \NormalTok{if (reorderObs) \{}
          \NormalTok{obsOrder <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\NormalTok{:}\KeywordTok{nrow}\NormalTok{(data))}
          \NormalTok{mf <-}\StringTok{ }\NormalTok{mf[obsOrder, ]}
          \NormalTok{Y <-}\StringTok{ }\NormalTok{Y[obsOrder, ]}
        \NormalTok{\}}
    \NormalTok{\}}
  \NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dla danego podzbioru wyznacz odpowiadającą jemu część pochodnej
częściowej funkcji log-wiarogoności ze zmienionym znakiem. Ponieważ
omawiane algorytmy rozwiązuja problem minimalizacji badanej funkcji, zaś
celem estymacji w modelu Coxa jest znalezienie parametrów modelu
maksymalizujących funkcję częściowej log-wiarogodności, zatem wzięcie do
minimalizacji funkcji z przeciwnym znakiem doprowadzi do wykorzystania
metod znajdujących minimum do znalezienia maksimum. Dla \(j\)-ego kroku
algorytmu i \(k\)-tej pochodnej cząstkowej dysponuje się podzbiorem
\(\mathcal{B}\) o liczności \(b\) (parametr \texttt{batchSize}), wtedy
\[-U^\mathcal{B}_k(\beta_j)=-\sum\limits_{i \in \mathcal{B}_\text{ind}}^{}U^\mathcal{B}_{k_{i}}(\beta_j)=-\sum\limits_{i \in \mathcal{B}_\text{ind}}^{}Y_i\Big(X_{ik}-\dfrac{\sum\limits_{l\in \mathscr{R}_\mathcal{B}(t_i)}^{} X_{lk} e^{X_l'\beta_j}}{\sum\limits_{l\in \mathscr{R}_\mathcal{B}(t_i)}^{} e^{X_l'\beta_j}}\Big),\]
gdzie \(b\) oznacza wielkość podzbioru \(\mathcal{B}\), zaś
\(\mathscr{R}_\mathcal{B}(t_i)\) to zbiór ryzyka dla podzbioru
\(\mathcal{B}\) w czasie \(t_i\).

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{U_ik <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DataTypeTok{ncol =} \KeywordTok{ncol}\NormalTok{(mf)-}\DecValTok{1}\NormalTok{,}
                 \DataTypeTok{nrow =} \KeywordTok{nrow}\NormalTok{(batchSample_variables))}
  \NormalTok{U_k <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(}\KeywordTok{ncol}\NormalTok{(mf)-}\DecValTok{1}\NormalTok{)}
  \NormalTok{for ( k in }\DecValTok{2}\NormalTok{:}\KeywordTok{ncol}\NormalTok{(mf)) \{ }\CommentTok{# 1st dimension is Y}
    \NormalTok{for (i in }\DecValTok{1}\NormalTok{:}\KeywordTok{nrow}\NormalTok{(batchSample_variables))\{}
      \NormalTok{l <-}\StringTok{ }\KeywordTok{which}\NormalTok{(batchSample_response[, }\DecValTok{1}\NormalTok{] <=}\StringTok{ }\NormalTok{batchSample_response[i, }\DecValTok{1}\NormalTok{])}
      \NormalTok{U_ik[i,k] <-}\StringTok{ }\NormalTok{-batchSample_variables[i, k] +}\StringTok{ }\KeywordTok{sum}\NormalTok{(batchSample_variables[l, k]*}
\StringTok{                                           }\KeywordTok{exp}\NormalTok{(batchSample_variables[l, ]%*%beta_j)/}
\StringTok{            }\KeywordTok{sum}\NormalTok{(}\KeywordTok{exp}\NormalTok{(batchSample_variables[l, ]%*%beta_j)) }
            
    \ErrorTok{\}}
  \NormalTok{U_k[k] <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(U_ik[, k])  }
  \ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

Następnie zaktualizuj parametry modelu.
\[\beta_{k_{j+1}} = \beta_{k_{j}} - \alpha_{j}U^{\mathcal{B}}_{k}(\beta_{k_{j}})\]

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{beta_j <-}\StringTok{ }\NormalTok{beta_j -}\StringTok{ }\KeywordTok{learningRates}\NormalTok{(j)*U_k}
\end{Highlighting}
\end{Shaded}

Przypisz nowy warunek stopu.

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{diff <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\KeywordTok{learningRates}\NormalTok{(j)*U_k))}
  \ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

Zwrócenie parametrów funkcji, gdy spełniony chociaż jeden warunek stopu.

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{fit <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  \NormalTok{fit$Call <-}\StringTok{ }\NormalTok{Call}
  \NormalTok{fit$mf <-}\StringTok{ }\NormalTok{mf}
  \NormalTok{fit$coeff <-}\StringTok{ }\NormalTok{beta_j}
  \NormalTok{fit$epochs_n <-}\StringTok{ }\NormalTok{epochs_n}
  \NormalTok{fit}
\ErrorTok{\}}
\CommentTok{#coxphSGD(Surv(time, status) ~ ph.ecog + age, data=lung)}
\end{Highlighting}
\end{Shaded}

\end{document}
